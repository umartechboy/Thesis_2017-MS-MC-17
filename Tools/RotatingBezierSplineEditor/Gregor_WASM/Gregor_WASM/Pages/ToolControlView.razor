@using RotatingBezierSplineEditor
@using SkiaSharp
@using SkiaSharp.Views.Blazor

<div style="width: @Width; height: @Height;"
     @onmousemove:stopPropagation="true"
     @onmousedown:preventDefault="true"
     @onmouseup:preventDefault="true"
     @onmouseenter:preventDefault="true"
     @onmouseleave:preventDefault="true"
     @onclick:preventDefault="true">
    <SKGLView @ref=skView
              style="width: 100%; height: 100vh;"
              OnPaintSurface="async (e) => await OnPaint(e)"
              IgnorePixelScaling="true"
              @onmousemove="OnMouseMove"
              @onmousedown="OnMouseDown"
              @onmouseup="OnMouseUp"
              @onmouseenter="OnMouseEnter"
              @onmouseleave="OnMouseLeave"
              @onclick="OnClick"></SKGLView>
</div>
@code {
    [Parameter]
    public string Width { get; set; } = "100%";
    [Parameter]
    public string Height { get; set; } = "100%";


    SKGLView skView;
    bool containsMouseCursor = false;
    bool _active = false;
    bool _dist = true;
    public async Task SetDistinctSelection(bool value) { _dist = value; await SetActive(Active); }
    public bool DistinctSelection { get => _dist; }
    [Parameter]
    public EventCallback<bool> MakeSiblingsActive { get; set; }
    [Parameter]
    public EventCallback OnActivated { get; set; }
    public bool Active { get => _active; }

    bool panelEnable = true;
    // Emulate Panel.Enable
    public bool Enabled
    {
        get { return panelEnable; }
        set
        {
            panelEnable = value;
            skView.Invalidate();
        }
    }
    public async Task SetActive(bool value)
    {
        if (DistinctSelection)
        {
            await MakeSiblingsActive.InvokeAsync(false);
        }
        if (value != _active)
        {
            // change the value first
            _active = value;
            // raise the events
            await OnActivated.InvokeAsync();
        }
    }
    SKImage icon;
    SKImage dull;
    int size;
    /// <summary>
    /// This is alternate to BackgroundImage creates a dull looking copy of the image as well.
    /// </summary>
    /// <param name="Image">Image to be used base icon</param>
    /// <param name="size">size of the rendered icon</param>
    public SKImage SetImage(SKImage Image, int size, SKImage dull = null)
    {
        this.size = size;
        icon = Image;
        // make new memory space for the dull image
        if (dull == null)
        {
            var bmp = SKBitmap.Decode(Image.Encode());
            // this method can be made fast by using Unsafe access. Create BitmapData using the specs of this bmp, "UnlockBits" on the bitmap using the new bitmap data. Read Scan0 of bmpData using Marshal.Copy, alter it, put back the data by locking the bits.
            for (int y = 0; y < bmp.Height; y++)
            {
                for (int x = 0; x < bmp.Width; x++)
                {
                    var c = bmp.GetPixel(x, y);
                    byte g = (byte)((c.Red + c.Green + c.Blue) / 3);
                    // get a gray level
                    bmp.SetPixel(x, y, new SKColor(g, g, g, (byte)(c.Alpha == 0 /*Do it only on non transparent pixels*/? 0 : 60)));
                }
            }
            dull = SKImage.FromBitmap(bmp);
        }
        this.dull = dull;
        return dull;
    }
    protected async Task OnPaint(SKPaintGLSurfaceEventArgs e)
    {
        if (icon == null) // this is needed for the UI Editor which is not familiar with our objects and will call this function regardless of the values to show in the editor.
            return;
        var Width = e.Info.Width;
        var Height = e.Info.Width;
        var rect = new System.Drawing.RectangleF(0, 0, size, (size * icon.Height) / icon.Width);
        var tRect = new System.Drawing.RectangleF(Width / 2 - rect.Width / 2, Height / 2 - rect.Height / 2, rect.Width, rect.Height);
        rect.Inflate(-3, -3);
        if (containsMouseCursor)
            rect.Inflate(3, 3);
        e.Surface.Canvas.DrawImage(Active ? icon : dull, new SKRect(tRect.Left, tRect.Top, tRect.Right, tRect.Bottom));
    }
    // Emulate control UI

    SKPoint lastMove;

    public void OnMouseMove(Microsoft.AspNetCore.Components.Web.MouseEventArgs e)
    {
        lastMove = new SKPoint((float)e.OffsetX, (float)e.OffsetY);
    }
    public void OnMouseDown(Microsoft.AspNetCore.Components.Web.MouseEventArgs e)
    {
    }
    public void OnMouseUp(Microsoft.AspNetCore.Components.Web.MouseEventArgs e)
    {
    }
    public void OnMouseEnter(Microsoft.AspNetCore.Components.Web.MouseEventArgs e)
    {
    }
    public void OnMouseLeave(Microsoft.AspNetCore.Components.Web.MouseEventArgs e)
    {
    }
    public void OnClick(EventArgs e)
    {
    }

    // Anchor EditToolControl only
    public AnchorDrawMode TargetPart {get;set;}
}
